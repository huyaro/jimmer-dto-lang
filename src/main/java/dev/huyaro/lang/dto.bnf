{
  parserClass="dev.huyaro.lang.parser.DtoParser"
  parserUtilClass="dev.huyaro.lang.parser.DtoParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Dto"
  psiImplClassSuffix="Impl"
  psiPackage="dev.huyaro.lang.psi"
  psiImplPackage="dev.huyaro.lang.psi.impl"
  psiImplUtilClass="dev.huyaro.lang.psi.impl.DtoPsiImplUtil"

  elementTypeHolderClass="dev.huyaro.lang.psi.DtoTypes"
  elementTypeClass="dev.huyaro.lang.psi.DtoElementType"
  tokenTypeClass="dev.huyaro.lang.psi.DtoTokenType"

  tokens=[
    LBRACE       =  "{"
    RBRACE       =  "}"
    LBRACK       =  "["
    RBRACK       =  "]"
    LPAREN       =  "("
    RPAREN       =  ")"
    LANGLE       =  "<"
    RANGLE       =  ">"
    COMMA        =  ","
    SEMICOLON    =  ";"
    DOT          =  "."
    AT           = '@'
    HASH         = '#'
    EQUAL        = '='
    OPTNULL      = '?'
    CARET        = '^'
    DOLOR        = '$'
    COLON        = ':'
    STAR         = '*'
    MINUS        = '-'
    RIGHT_ARROW  = '->'
    ABSTRACT     = 'abstract'
    INPUT        = 'input'
    IMPORT       = 'import'
    KEY_AS       = 'as'

    Space='regexp:\s+'
    Id='regexp:\w+'
    // 中英文带全角符号
    String="regexp:(\"([\u4e00-\u9fa5\uff00-\uffff|a-zA-Z0-9_.])*\")|('[a-zA-Z0-9_.]*')"
    // 字符串正则表达式
    StringLiteral='regexp:"[^"]*"'
    Number='regexp:-?(0|[1-9][0-9]*)(\.[0-9]+)?([e|E][+-]?[0-9]+)?'
    BlockComment="regexp:/\*(.|\n)*?\*/"
    LineComment="regexp://.*\n"
  ]
}

dtoFile ::= importStatement* dtoType*
importStatement ::=
    'import' Identifier ('.' Identifier)*
    (
    '.' '{' importedType (',' importedType)* '}'
    | 'as' Identifier
    )?
importedType ::= Identifier ('as' Identifier)?

dtoType ::=
    annotation*
    modifier* Identifier
    (':' Identifier (',' Identifier)*)?
    dtoBody

modifier ::= 'abstract' | 'input' | 'input-only'
dtoBody ::=  '{' (explicitProp (','|';')?)* '}'
explicitProp ::=
    allScalars
    | aliasGroup
    | negativeProp
    | userProp
    | positiveProp

allScalars ::=
    '#' Identifier
    ('(' qualifiedName (',' qualifiedName)* ')')?
    ('?'|'!')?

aliasGroup ::= aliasPattern '{' aliasGroupProp* '}'
aliasPattern ::=
    'as' '(' '^'? Identifier? '$'? '->' Identifier? ')'
aliasGroupProp ::= allScalars | positiveProp

positiveProp ::=
    annotation*
    '+'?
    (Identifier '(' Identifier ')' | Identifier)
    ('?'|'!')?
    ('as' Identifier)?
    (annotation* dtoBody '*'?)?

negativeProp ::= '-' Identifier

userProp ::=
    annotation*
    Identifier ':' typeRef
typeRef ::=
    qualifiedName
    ('<' genericModifier? genericArgument '>')?
    '?'?
genericModifier ::= 'in' | 'out'
genericArgument ::= '*' | (Identifier ',' Identifier | Identifier '?'?)

qualifiedName ::= Identifier ('.' Identifier)*
annotationName ::= Identifier ('.' Identifier)*
annotation ::= '@' annotationName ('(' annotationArguments? ')')?
annotationArguments ::=
    annotationNamedArgument (',' annotationNamedArgument)*
    | annotationValue (',' annotationNamedArgument)*
annotationNamedArgument ::= Identifier '=' annotationValue
annotationValue ::=
    annotationSingleValue
    | annotationArrayValue
annotationSingleValue ::=
    BooleanLiteral
    | Number
    | String
    | StringLiteral
    | qualifiedName
    | annotation
    | nestedAnnotation
annotationArrayValue ::=
      '[' annotationSingleValue (',' annotationSingleValue)* ']'
    | '{' annotationSingleValue (',' annotationSingleValue)* '}'
nestedAnnotation ::= qualifiedName '(' annotationArguments? ')'

Identifier ::= Id
BooleanLiteral ::= 'true' | 'false'
